---
description:
globs:
alwaysApply: true
---

You are an expert in WordPress, WooCommerce, PHP, and related web development technologies.

Key Principles
- Write concise, technical code with accurate PHP examples.
- Follow WordPress and WooCommerce coding standards and best practices.
- Use object-oriented programming when appropriate, focusing on modularity.
- Prefer iteration and modularization over duplication.
- Use descriptive function, variable, and file names.
- Use lowercase with hyphens for directories (e.g., wp-content/themes/my-theme, wp-content/plugins/my-plugin).
- Favor hooks (actions and filters) for extending functionality.
- When asked for a specific color, use the color from the design / already defined colors.
- **CRITICAL: When a color is mentioned, ALWAYS use Tailwind CSS color classes from the project's color palette. Only use specific color codes (hex, rgb) when explicitly requested by the user. Check tailwind.config.js for available colors.**

Function Naming
- All custom functions must start with 'kj_' to ensure consistency and prevent naming conflicts.

GitHub
- I'm using Github to store my code.
- Give me ideas if any file has to be added to the .gitignore file.

PHP/WordPress/WooCommerce
- Use PHP 7.4+ features when appropriate (e.g., typed properties, arrow functions).
- Follow WordPress PHP Coding Standards.
- Use strict typing when possible: `declare(strict_types=1);`
- Utilize WordPress core functions and APIs when available.
- File structure: Follow WordPress theme and plugin directory structures and naming conventions.
- Implement proper error handling and logging:
  - Use WordPress debug logging features.
  - Create custom error handlers when necessary.
  - Use try-catch blocks for expected exceptions.
- Use WordPress's built-in functions for data validation and sanitization.
- Implement proper nonce verification for form submissions.
- Utilize WordPress's database abstraction layer (wpdb) for database interactions.
- Use `prepare()` statements for secure database queries.
- Implement proper database schema changes using `dbDelta()` function.

Build By Design
- When asked to create new components by design (image input), build it with responsiveness in mind. Don't use hardcoded values, use variables instead. Only use hardcoded values when it's asked for.
- When there is a Button in the design, check if one of the already created buttons can be used.

Components
- When there are recurring items in a template, create a component for it.
- Components should be reusable and independent.
- When creating a component, always create a SCSS file for it.

Advanced Custom Fields
- Use ACF fields to create content blocks.
- When asked to create new components, automatically create the ACF fields for it when otherwise not specified.
- Image Fields should always be displayed as small as possible in the admin area.
- **CRITICAL: When editing ANY ACF JSON file, ALWAYS update the "modified" field at the end of the file to the current Unix timestamp (use `date +%s` command). This is required for ACF to recognize field changes. Never forget this step.**
- **CRITICAL: Buttons in layouts: Always use a repeater field for buttons, even if only one button is needed. This allows flexibility for future expansion. If explicitly requested for a maximum of 1 button, still use a repeater but set `max: 1` in the repeater field configuration.**

CSS and Tailwind
- **CRITICAL: When writing CSS, ALWAYS prefer Tailwind's `@apply` directive over writing raw CSS properties when equivalent Tailwind utilities exist. Use raw CSS only when Tailwind utilities are not available or when specific CSS features (like transforms, transitions, pseudo-elements, etc.) require it.**
- Examples:
  - ✅ Good: `@apply flex items-center gap-4;` instead of `display: flex; align-items: center; gap: 1rem;`
  - ✅ Good: `@apply text-white bg-primary;` instead of `color: white; background-color: #FFD500;`
  - ✅ Good: `@apply w-full h-auto;` instead of `width: 100%; height: auto;`
  - ⚠️ Acceptable: `transform: rotate(-90deg);` (when specific transform values are needed)
  - ⚠️ Acceptable: `transition: top 0.1s ease, height 0.1s ease;` (when multiple properties need different timings)

Dependencies
- WordPress (latest stable version)
- WooCommerce (latest stable version)
- Composer for dependency management (when building advanced plugins or themes)

WordPress and WooCommerce Best Practices
- Use WordPress hooks (actions and filters) instead of modifying core files.
- Implement proper theme functions using functions.php.
- Use WordPress's built-in user roles and capabilities system.
- Utilize WordPress's transients API for caching.
- Implement background processing for long-running tasks using `wp_cron()`.
- Use WordPress's built-in testing tools (WP_UnitTestCase) for unit tests.
- Implement proper internationalization and localization using WordPress i18n functions.
- Implement proper security measures (nonces, data escaping, input sanitization).
- Use `wp_enqueue_script()` and `wp_enqueue_style()` for proper asset management.
- Implement custom post types and taxonomies when appropriate.
- Use WordPress's built-in options API for storing configuration data.
- Implement proper pagination using functions like `paginate_links()`.
- Leverage action and filter hooks provided by WooCommerce for extensibility.
  - Example: `add_action('woocommerce_before_add_to_cart_form', 'your_function');`
- Adhere to WooCommerce's coding standards in addition to WordPress standards.
- Use WooCommerce's naming conventions for functions and variables.
- Use built-in WooCommerce functions instead of reinventing the wheel.
  - Example: `wc_get_product()` instead of `get_post()` for retrieving products.
- Use WooCommerce's Settings API for plugin configuration pages.
- Integrate your settings seamlessly into WooCommerce's admin interface.
- Override WooCommerce templates in your plugin for custom layouts.
  - Place overridden templates in `your-plugin/woocommerce/` directory.
- Use WooCommerce's CRUD classes and data stores for managing custom data.
- Extend existing data stores for custom functionality.
- Use WooCommerce session handling for storing temporary data.
  - Example: `WC()->session->set('your_key', 'your_value');`
- If extending the REST API, follow WooCommerce's API structure and conventions.
  - Use proper authentication and permission checks.
- Use WooCommerce's notice system for user-facing messages.
  - Example: `wc_add_notice('Your message', 'error');`
- Extend WooCommerce's email system for custom notifications.
  - Use `WC_Email` class for creating new email types.
- Check for WooCommerce activation and version compatibility.
  - Gracefully disable functionality if requirements aren't met.
- Use WooCommerce's translation functions for text strings.
- Support RTL languages in your plugin's CSS.
- Utilize WooCommerce's logging system for debugging.
  - Example: `wc_get_logger()->debug('Your debug message', array('source' => 'your-plugin'));`

Key Conventions
1. Follow WordPress's plugin API for extending functionality.
2. Use WordPress's template hierarchy for theme development.
3. Implement proper data sanitization and validation using WordPress functions.
4. Use WordPress's template tags and conditional tags in themes.
5. Implement proper database queries using $wpdb or WP_Query.
6. Use WordPress's authentication and authorization functions.
7. Implement proper AJAX handling using admin-ajax.php or REST API.
8. Use WordPress's hook system for modular and extensible code.
9. Implement proper database operations using WordPress transactional functions.
10. Use WordPress's WP_Cron API for scheduling tasks.

This comprehensive set of rules and conventions helps ensure that your WordPress and WooCommerce projects are consistent, maintainable, and aligned with the best practices within the community. Let me know if you need further customization or examples for specific points!

Figma → WordPress Theme Workflow (Cursor AI Agent)

Doel: vanuit een Figma design (screenshots/frames) zo snel mogelijk een **Pagebuilder-block** bouwen die 1-op-1 klopt, herbruikbaar is en netjes te beheren is via ACF.

### Design fidelity (non-negotiables)
- Wees **extreem kritisch** op design details: **border-radius, schaduw, borders, gradients, icon sizes, line-heights** moeten **exact** volgens Figma.
- Werk **responsive-first**: ontwerp en implementeer direct voor minimaal **mobile + desktop** (en liefst tablet waar relevant). Denk aan stacking, order, spacing, typografie scaling en content edge-cases.
- Nooit “ongeveer goed”: als waardes niet duidelijk zijn, vraag om de token/waarde (of laat de USER het bevestigen) i.p.v. gokken.

### Navigatie: mobiel menu (standaard gedrag)
- Mobiel menu is standaard een **off-canvas panel dat vanaf de rechterzijde inschuift** (met overlay).
- Submenu’s moeten **altijd** kunnen uitklappen via een **chevron toggle** (niet alleen via link click).
- Toegankelijkheid (a11y) is verplicht:
  - Chevron is een `button` met `aria-expanded` + `aria-controls`.
  - Keyboard support: Tab/Enter/Space werkt logisch; focus styles zichtbaar.
  - ESC sluit het menu; overlay click sluit het menu; bij open menu is er geen “scroll bleed” op de body.

### Input contract (wat de USER aanlevert)
- **Design input**: bij voorkeur 1 of meer Figma frame exports (PNG) per sectie + (optioneel) link naar het Figma bestand/frame.
- **Context**: welke template(s) gebruiken dit (bv. `page.php` via `templates/pagebuilder/loop.php`) en of het een **Pagebuilder block** of een **component** moet zijn.
- **Content model**: welke delen zijn dynamisch (title, tekst, cards, buttons, images, etc.) en welke zijn fixed.
- **Responsive intent**: minimaal mobile + desktop; noem afwijkingen (stacking, order, spacing, hides).

Als deze input ontbreekt: stel maximaal 5 gerichte vragen en start daarna met een “best guess” implementatie.

### Repo-conventies (heel specifiek voor `kj-boilerplate`)
- **Pagebuilder block structuur**:
  - Folder: `templates/pagebuilder/<slug>/`
  - Files: `<slug>.php`, `<slug>.css`, `<slug>.js` (ook als `.js` leeg is)
  - Render: `templates/pagebuilder/loop.php` include’t automatisch op basis van `get_row_layout()`.
- **ACF (Flex content)**:
  - Voeg een layout toe aan `acf-json/group_pagebuilder.json` met `name` exact gelijk aan `<slug>`.
  - Maak een layout field group `acf-json/group_layout_<slug>.json` (meestal `active: false`) en clone die in de layout via `type: clone` (zoals `hero` en `text-image`).
  - **Altijd** na ACF JSON edits: update het `"modified"` veld naar een actuele Unix timestamp (`date +%s`).
- **Styling (Tailwind + block CSS)**:
  - Gebruik Tailwind utilities in markup voor layout/spacing, gecombineerd met een block class + BEM elementen (bv. `my-block`, `my-block__title`) voor specifieke styling.
  - **Kleuren**: gebruik project Tailwind classes (zie `tailwind.config.js`). Gebruik géén hex/rgb tenzij expliciet gevraagd.
  - **Radius & shadows**: neem deze **exact** over uit design (bij voorkeur via bestaande utilities/tokens; geen willekeurige “close enough” waardes).
  - Voeg nieuwe block CSS altijd toe aan `assets/css/input.css` via `@import '../../templates/pagebuilder/<slug>/<slug>.css';`.
- **JavaScript bundling**:
  - Voeg `<slug>` toe aan `scripts/build-pagebuilder-js.js` in `pagebuilderBlocks`.
  - Genereer `assets/js/pagebuilder.js` via `npm run build:js`.
- **Buttons**:
  - Hergebruik de bestaande button component (`templates/components/button.php`).
  - Voor ACF: hergebruik `group_button_fields` (clone) en render in templates via `kj_render_buttons()`.
- **Escaping & security**:
  - Gebruik `esc_html()`, `esc_attr()`, `esc_url()` en `wp_kses_post()` waar passend.
  - Sanitize ACF values bij output; ga uit van onbetrouwbare input.
- **Naming**:
  - Slugs altijd lowercase met hyphens (bv. `feature-grid`, `cta-banner`).
  - Alle custom PHP functions starten met `kj_`.

### Definition of Done (wat de agent moet opleveren)
- Het block is aangemaakt + gekoppeld in ACF + heeft styling/JS imports geregeld.
- Markup is semantisch (section/heading levels), toegankelijk (alt/aria waar nodig), en responsive.
- Er is geen duplication van bestaande componenten (bv. buttons).
- De theme build werkt: `npm run build` draait zonder errors (waar haalbaar).
- Design is pixel-precies: **border-radius, schaduwen, borders, gradients, icon sizes** zijn exact volgens Figma.
- Mobiel menu (indien relevant voor de scope) voldoet aan de “mobiel menu” afspraken: right slide-in + chevron submenu toggles + a11y.

### When User Says "git push"
When the user says "git push", execute these steps automatically in sequence:

1. **Check status**: Run `git status` to see all modified files
2. **Review changes**: Run `git diff` to understand what changed
3. **Build assets**: Run `npm run build` to compile Tailwind CSS and other assets
4. **Stage changes**: Run `git add .` to stage all files including dist/
5. **Create descriptive commit**: Write a clear commit message that:
   - Starts with a verb: Add, Update, Fix, Refactor, Improve
   - Describes WHAT changed (not HOW)
   - Is concise but informative (1-2 lines max)
   - Uses present tense
   - Examples:
     - "Add pricing cards with interactive foldouts and gradient badges"
     - "Update foldout spacing and fix grid height behavior"
     - "Fix responsive layout issues on mobile devices"
6. **Commit with co-author**: Format with heredoc for proper multiline:
   ```bash
   git commit -m "$(cat <<'EOF'
   [Your descriptive commit message here]
   )"
   ```
7. **Push to remote**: Run `git push origin main`
8. **Confirm**: Report completion with commit message and push status